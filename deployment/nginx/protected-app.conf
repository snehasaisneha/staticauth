# Protected App Template
# Copy this file for each app you want to protect with Gatekeeper
#
# CONFIGURE THESE (lines 12-30):
# ─────────────────────────────────────────────────────────────────────────────

# App identifier (must match the slug in Gatekeeper admin)
map $host $app_slug {
    default "my-app";
}

# App's public domain
map $host $app_domain {
    default "app.example.com";
}

# Where Gatekeeper is running (for auth validation)
upstream gatekeeper_auth {
    server 127.0.0.1:8000;
}

# Public URL of Gatekeeper (for login redirects)
map $host $gatekeeper_url {
    default "https://auth.example.com";
}

# Your app's backend (what to proxy to after auth succeeds)
upstream app_backend {
    server 127.0.0.1:3000;
}

# Optional: Enable auth caching to reduce backend load
# Add this line to nginx.conf http{} block first:
# proxy_cache_path /tmp/gk_auth levels=1:2 keys_zone=gk_auth:1m max_size=10m inactive=5m;
map $host $enable_auth_cache {
    default "no";  # Set to "yes" after adding proxy_cache_path
}

# ─────────────────────────────────────────────────────────────────────────────
# END CONFIGURATION - Do not edit below unless you know what you're doing
# ─────────────────────────────────────────────────────────────────────────────

server {
    listen 80;
    server_name $app_domain;

    # For SSL: uncomment and run `sudo certbot --nginx -d app.example.com`
    # listen 443 ssl http2;
    # ssl_certificate /etc/letsencrypt/live/$app_domain/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/$app_domain/privkey.pem;

    # Internal auth validation endpoint
    location = /_gatekeeper/validate {
        internal;
        proxy_pass http://gatekeeper_auth/api/v1/auth/validate;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-GK-App $app_slug;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;

        # Auth caching (reduces load on Gatekeeper)
        # Uncomment after adding proxy_cache_path to nginx.conf
        # proxy_cache gk_auth;
        # proxy_cache_key "$cookie_session";
        # proxy_cache_valid 200 5m;
        # proxy_cache_valid 401 403 10s;
    }

    # All requests require authentication
    location / {
        auth_request /_gatekeeper/validate;

        # Capture auth headers from Gatekeeper
        auth_request_set $auth_user $upstream_http_x_auth_user;
        auth_request_set $auth_role $upstream_http_x_auth_role;

        # Forward auth info to your app
        proxy_set_header X-Auth-User $auth_user;
        proxy_set_header X-Auth-Role $auth_role;

        # Handle auth failures
        error_page 401 = @login_redirect;
        error_page 403 = @forbidden;

        # Proxy to your app
        proxy_pass http://app_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support (if your app needs it)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Redirect to Gatekeeper login
    location @login_redirect {
        return 302 $gatekeeper_url/signin?redirect=$scheme://$host$request_uri;
    }

    # Access denied page
    location @forbidden {
        default_type text/plain;
        return 403 "Access denied. You don't have permission to access this app.";
    }
}
