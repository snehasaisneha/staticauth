# =============================================================================
# Protected App Template
# =============================================================================
# Copy this file for each app you want to protect with Gatekeeper
#
# 1. Copy: sudo cp protected-app.conf /etc/nginx/sites-available/myapp.example.com
# 2. Edit the CONFIGURATION section below
# 3. Enable: sudo ln -s /etc/nginx/sites-available/myapp.example.com /etc/nginx/sites-enabled/
# 4. Register in Gatekeeper: uv run gk apps add --slug myapp --name "My App"
# 5. Reload: sudo nginx -t && sudo systemctl reload nginx
# =============================================================================

# =============================================================================
# CONFIGURATION - Edit these values
# =============================================================================

# App identifier - MUST match the slug registered in Gatekeeper
set $app_slug "myapp";

# App's public domain
set $app_domain "myapp.example.com";

# Base domain for cookies/redirects (with leading dot for subdomains)
set $base_domain "example.com";

# Gatekeeper backend address (where Gatekeeper API runs)
upstream gatekeeper_auth {
    server 127.0.0.1:8000;
    keepalive 8;
}

# Your app's backend
# Option A: Proxy to a running service
upstream app_backend {
    server 127.0.0.1:3000;
    keepalive 8;
}

# Option B: Serve static files (set this path, comment out upstream above)
# set $static_root "/var/www/myapp";

# =============================================================================
# END CONFIGURATION
# =============================================================================

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name myapp.example.com;  # EDIT: Match $app_domain

    # SSL certificates - EDIT paths
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;

    # -------------------------------------------------------------------------
    # Internal auth validation endpoint
    # -------------------------------------------------------------------------
    location = /_gatekeeper/validate {
        internal;

        proxy_pass http://gatekeeper_auth/api/v1/auth/validate;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-GK-App $app_slug;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;

        # Auth caching (optional - reduces load on Gatekeeper)
        # First add to nginx.conf http{} block:
        #   proxy_cache_path /var/cache/nginx/gk levels=1:2 keys_zone=gk_auth:1m max_size=10m inactive=5m;
        # Then uncomment:
        # proxy_cache gk_auth;
        # proxy_cache_key "$cookie_gk_session";
        # proxy_cache_valid 200 5m;
        # proxy_cache_valid 401 403 10s;
    }

    # -------------------------------------------------------------------------
    # Protected content - requires authentication
    # -------------------------------------------------------------------------
    location / {
        # Require auth for all requests
        auth_request /_gatekeeper/validate;

        # Capture auth info from Gatekeeper response headers
        auth_request_set $auth_user $upstream_http_x_auth_user;
        auth_request_set $auth_user_id $upstream_http_x_auth_user_id;
        auth_request_set $auth_role $upstream_http_x_auth_role;

        # Handle auth failures
        error_page 401 = @login_redirect;
        error_page 403 = @access_denied;

        # =====================================================================
        # Option A: Proxy to backend service
        # =====================================================================
        # Forward authenticated user info to your app
        proxy_set_header X-Auth-User $auth_user;
        proxy_set_header X-Auth-User-Id $auth_user_id;
        proxy_set_header X-Auth-Role $auth_role;

        # Proxy settings
        proxy_pass http://app_backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support (if needed)
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeouts
        proxy_connect_timeout 10s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # =====================================================================
        # Option B: Serve static files (uncomment and comment out proxy above)
        # =====================================================================
        # root $static_root;
        # index index.html;
        # try_files $uri $uri/ $uri.html =404;
        #
        # # Cache static assets
        # location ~* \.(?:css|js|jpg|jpeg|png|gif|ico|svg|woff|woff2)$ {
        #     expires 1y;
        #     add_header Cache-Control "public, immutable";
        # }
    }

    # -------------------------------------------------------------------------
    # Login redirect (401 - not authenticated)
    # -------------------------------------------------------------------------
    location @login_redirect {
        # Redirect to Gatekeeper login with return URL
        return 302 https://auth.$base_domain/signin?redirect=$scheme://$host$request_uri;
    }

    # -------------------------------------------------------------------------
    # Access denied (403 - authenticated but no app access)
    # -------------------------------------------------------------------------
    location @access_denied {
        # Option A: Redirect to access request page
        return 302 https://auth.$base_domain/request-access?app=$app_slug&redirect=$scheme://$host$request_uri;

        # Option B: Show inline error page (uncomment to use instead)
        # default_type text/html;
        # return 403 '<!DOCTYPE html>
        # <html>
        # <head><title>Access Denied</title></head>
        # <body style="font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center;">
        #     <h1>Access Denied</h1>
        #     <p>You don\'t have permission to access this application.</p>
        #     <p><a href="https://auth.$base_domain">Return to Gatekeeper</a></p>
        # </body>
        # </html>';
    }
}

# =============================================================================
# HTTP redirect (optional - if not using main routing.conf)
# =============================================================================
server {
    listen 80;
    listen [::]:80;
    server_name myapp.example.com;  # EDIT: Match $app_domain

    # Certbot challenge
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    # Redirect to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}
