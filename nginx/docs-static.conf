# Protected Static Docs Site - Internal Server Config
# Optimized for serving static documentation (Sphinx, MkDocs, Docusaurus, etc.)
# with auth caching to reduce backend load.
#
# Listens on HTTP only - SSL termination happens on routing server
#
# Replace placeholders:
#   {{GATEKEEPER_PORT}} - Gatekeeper backend port (default: 8000)
#   {{APP_SLUG}} - App slug registered in Gatekeeper
#   {{DOCS_ROOT}} - Path to built docs (e.g., /var/www/docs/build)
#   {{GATEKEEPER_PUBLIC_URL}} - Public Gatekeeper URL for redirects

# Auth response cache - ADD THIS TO http{} BLOCK IN nginx.conf
# proxy_cache_path /tmp/gk_auth_cache levels=1:2 keys_zone=gk_auth:1m max_size=10m inactive=5m;

server {
    listen 80;
    server_name _;

    root {{DOCS_ROOT}};
    index index.html;

    # Internal auth_request location with caching
    location = /_gatekeeper/validate {
        internal;
        proxy_pass http://127.0.0.1:{{GATEKEEPER_PORT}}/api/v1/auth/validate;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-GK-App {{APP_SLUG}};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        proxy_set_header Cookie $http_cookie;

        # Cache auth responses - dramatically reduces backend load
        # Session cookie is the cache key, so each user gets their own cached result
        proxy_cache gk_auth;
        proxy_cache_key "$cookie_session";
        proxy_cache_valid 200 5m;      # Cache valid sessions for 5 minutes
        proxy_cache_valid 401 403 10s; # Cache failures briefly
    }

    # Protected HTML pages - require authentication
    location / {
        auth_request /_gatekeeper/validate;
        auth_request_set $auth_user $upstream_http_x_auth_user;
        auth_request_set $auth_role $upstream_http_x_auth_role;

        error_page 401 = @login_redirect;
        error_page 403 = @forbidden;

        try_files $uri $uri/ $uri.html $uri/index.html =404;
    }

    # Static assets - OPTION A: Skip auth for better performance
    # Use this if your docs aren't highly sensitive (CSS/JS/images don't leak info)
    # location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|map)$ {
    #     expires 1y;
    #     add_header Cache-Control "public, immutable";
    # }

    # Static assets - OPTION B: Auth with caching (default, more secure)
    # Assets still require auth but benefit from the cached auth response
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|map)$ {
        auth_request /_gatekeeper/validate;
        error_page 401 = @login_redirect;
        error_page 403 = @forbidden;

        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Redirect to Gatekeeper login on 401
    location @login_redirect {
        set $redirect_scheme $http_x_forwarded_proto;
        if ($redirect_scheme = "") {
            set $redirect_scheme $scheme;
        }
        return 302 {{GATEKEEPER_PUBLIC_URL}}/signin?redirect=$redirect_scheme://$host$request_uri;
    }

    # Show forbidden page on 403
    location @forbidden {
        return 403 "Access denied. You don't have permission to access this app.";
        add_header Content-Type text/plain;
    }
}
